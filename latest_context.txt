Project Path: src

Source Tree:

```txt
src
└── code2prompt_mcp
    ├── __init__.py
    └── main.py

```

`src/code2prompt_mcp/__init__.py`:

```py
   1 | def hello() -> str:
   2 |     return "Hello from code2prompt-mcp!"

```

`src/code2prompt_mcp/main.py`:

```py
   1 | """
   2 | Code2Prompt MCP Server
   3 | 
   4 | An MCP server that allows LLMs to extract context from codebases using the code2prompt_rs SDK.
   5 | """
   6 | 
   7 | from typing import Dict, List, Optional, Any
   8 | from mcp.server.fastmcp import FastMCP
   9 | import logging
  10 | import colorlog
  11 | from pathlib import Path
  12 | from code2prompt_rs import Code2Prompt
  13 | 
  14 | # Initialize logger at module level
  15 | logger = logging.getLogger(__name__)
  16 | 
  17 | mcp = FastMCP("code2prompt")
  18 | 
  19 | 
  20 | @mcp.tool()
  21 | async def get_context(
  22 |     path: str = ".",
  23 |     include_patterns: List[str] = [],
  24 |     exclude_patterns: List[str] = [],
  25 |     include_priority: bool = False,
  26 |     line_numbers: bool = True,
  27 |     absolute_paths: bool = False,
  28 |     full_directory_tree: bool = False,
  29 |     code_blocks: bool = True,
  30 |     follow_symlinks: bool = False,
  31 |     include_hidden: bool = False,
  32 |     template: Optional[str] = None,
  33 |     encoding: Optional[str] = "cl100k",
  34 | ) -> Dict[str, Any]:
  35 |     """
  36 |     Retrieve context from a codebase using code2prompt with the specified parameters.
  37 |     
  38 |     Args:
  39 |         path: Path to the codebase
  40 |         include_patterns: List of glob patterns for files to include
  41 |         exclude_patterns: List of glob patterns for files to exclude
  42 |         include_priority: Give priority to include patterns
  43 |         line_numbers: Add line numbers to code
  44 |         absolute_paths: Use absolute paths instead of relative paths
  45 |         full_directory_tree: List the full directory tree
  46 |         code_blocks: Wrap code in markdown code blocks
  47 |         follow_symlinks: Follow symbolic links
  48 |         include_hidden: Include hidden directories and files
  49 |         template: Custom Handlebars template
  50 |         encoding: Token encoding (cl100k, gpt2, p50k_base)
  51 |     
  52 |     Returns:
  53 |         Dictionary with the prompt and metadata
  54 |     """
  55 |     logger.info(f"Getting context from {path} with include patterns: {include_patterns}, exclude patterns: {exclude_patterns}")
  56 |     
  57 |     # Initialize the Code2Prompt instance with all parameters
  58 |     prompt = Code2Prompt(
  59 |         path=path,
  60 |         include_patterns=include_patterns,
  61 |         exclude_patterns=exclude_patterns,
  62 |         include_priority=include_priority,
  63 |         line_numbers=line_numbers,
  64 |         absolute_paths=absolute_paths,
  65 |         full_directory_tree=full_directory_tree,
  66 |         code_blocks=code_blocks,
  67 |         follow_symlinks=follow_symlinks,
  68 |         include_hidden=include_hidden,
  69 |     )
  70 |     
  71 |     # Generate the prompt directly using the instance method
  72 |     # Note: sort_by configuration should be added if supported by the SDK
  73 |     result = prompt.generate(template=template, encoding=encoding)
  74 |     
  75 |     # Return structured result
  76 |     return {
  77 |         "prompt": result.prompt,
  78 |         "directory": str(result.directory),
  79 |         "token_count": result.token_count
  80 |     }
  81 | 
  82 | 
  83 | @mcp.tool()
  84 | async def get_context_for_gemini(
  85 |     path: str = ".",
  86 |     include_patterns: List[str] = [],
  87 |     exclude_patterns: List[str] = [],
  88 |     include_priority: bool = False,
  89 |     line_numbers: bool = True,
  90 |     absolute_paths: bool = False,
  91 |     full_directory_tree: bool = False,
  92 |     code_blocks: bool = True,
  93 |     follow_symlinks: bool = False,
  94 |     include_hidden: bool = False,
  95 |     template: Optional[str] = None,
  96 |     encoding: Optional[str] = "cl100k",
  97 | ) -> str:
  98 |     """
  99 |     Retrieve context from a codebase using code2prompt and save it to a file.
 100 |     
 101 |     This function works identically to get_context but saves the output to 
 102 |     "latest_context.txt" in the current working directory and returns the 
 103 |     absolute file path instead of the content.
 104 |     
 105 |     Args:
 106 |         path: Path to the codebase
 107 |         include_patterns: List of glob patterns for files to include
 108 |         exclude_patterns: List of glob patterns for files to exclude
 109 |         include_priority: Give priority to include patterns
 110 |         line_numbers: Add line numbers to code
 111 |         absolute_paths: Use absolute paths instead of relative paths
 112 |         full_directory_tree: List the full directory tree
 113 |         code_blocks: Wrap code in markdown code blocks
 114 |         follow_symlinks: Follow symbolic links
 115 |         include_hidden: Include hidden directories and files
 116 |         template: Custom Handlebars template
 117 |         encoding: Token encoding (cl100k, gpt2, p50k_base)
 118 |     
 119 |     Returns:
 120 |         Absolute file path to the created "latest_context.txt" file
 121 |         
 122 |     Raises:
 123 |         Exception: If file cannot be created due to permissions, disk space, or other IO issues
 124 |     """
 125 |     logger.info(f"Getting context from {path} for Gemini file output")
 126 |     
 127 |     # Step 1: Get context using existing function
 128 |     try:
 129 |         context_result = await get_context(
 130 |             path=path,
 131 |             include_patterns=include_patterns,
 132 |             exclude_patterns=exclude_patterns,
 133 |             include_priority=include_priority,
 134 |             line_numbers=line_numbers,
 135 |             absolute_paths=absolute_paths,
 136 |             full_directory_tree=full_directory_tree,
 137 |             code_blocks=code_blocks,
 138 |             follow_symlinks=follow_symlinks,
 139 |             include_hidden=include_hidden,
 140 |             template=template,
 141 |             encoding=encoding
 142 |         )
 143 |     except Exception as e:
 144 |         logger.error(f"Failed to generate context: {str(e)}")
 145 |         raise Exception(f"Failed to generate codebase context: {str(e)}")
 146 |     
 147 |     # Step 2: Define output file path in current working directory
 148 |     output_file = Path.cwd() / "latest_context.txt"
 149 |     logger.info(f"Writing context to file: {output_file}")
 150 |     
 151 |     # Step 3: Write content to file with comprehensive error handling
 152 |     try:
 153 |         # Handle empty context case
 154 |         content = context_result["prompt"]
 155 |         if not content or content.strip() == "":
 156 |             content = "# No context generated\n\nNo files were found or all files were excluded by the specified patterns.\n"
 157 |         
 158 |         # Write content atomically using pathlib
 159 |         output_file.write_text(content, encoding="utf-8")
 160 |         logger.info(f"Successfully wrote {len(content)} characters to {output_file}")
 161 |         
 162 |     except PermissionError as e:
 163 |         error_msg = f"Permission denied when writing to {output_file}: {str(e)}"
 164 |         logger.error(error_msg)
 165 |         raise Exception(error_msg)
 166 |     except OSError as e:
 167 |         if e.errno == 28:  # ENOSPC - No space left on device
 168 |             error_msg = f"Insufficient disk space to write context file to {output_file}"
 169 |             logger.error(error_msg)
 170 |             raise Exception(error_msg)
 171 |         else:
 172 |             error_msg = f"Failed to write context file to {output_file}: {str(e)}"
 173 |             logger.error(error_msg)
 174 |             raise Exception(error_msg)
 175 |     except Exception as e:
 176 |         error_msg = f"Unexpected error writing context file to {output_file}: {str(e)}"
 177 |         logger.error(error_msg)
 178 |         raise Exception(error_msg)
 179 |     
 180 |     # Step 4: Return absolute path
 181 |     absolute_path = str(output_file.absolute())
 182 |     logger.info(f"Context successfully saved to: {absolute_path}")
 183 |     return absolute_path
 184 | 
 185 | 
 186 | if __name__ == "__main__":
 187 |     # Initialize FastMCP server
 188 |     handler = colorlog.StreamHandler()
 189 |     formatter = colorlog.ColoredFormatter(
 190 |         "%(log_color)s%(levelname)-8s%(reset)s %(blue)s%(message)s",
 191 |         datefmt=None,
 192 |         reset=True,
 193 |         log_colors={
 194 |             "DEBUG": "cyan",
 195 |             "INFO": "green",
 196 |             "WARNING": "yellow",
 197 |             "ERROR": "red",
 198 |             "CRITICAL": "red,bg_white",
 199 |         },
 200 |         secondary_log_colors={},
 201 |         style="%",
 202 |     )
 203 |     handler.setFormatter(formatter)
 204 |     logger.addHandler(handler)
 205 |     logger.setLevel(logging.DEBUG)
 206 |     mcp.run(transport='stdio')

```